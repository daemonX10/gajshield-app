import xgboost as xgb
import numpy as np
from collections import Counter

# Feature extraction function (unchanged)
def extract_features(file_path):
    try:
        with open(file_path, 'r') as f:
            content = f.read().strip().split()
            bytes_list = [b for b in content if b != '??' and len(b) == 2]
            bytes_int = [int(b, 16) for b in bytes_list]
            byte_counts = Counter(bytes_int)
            feature_vector = [byte_counts.get(i, 0) / max(1, len(bytes_int)) for i in range(256)]
            return feature_vector
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return [0] * 256

# Malware class mapping (updated with "Normal" class)
malware_mapping = {
    0: 'Likely Normal (No significant malware characteristics detected) - keywords: benign, safe, non-malicious',
    1: 'Ramnit (Windows) - keywords: credential theft, HTML injection, banking fraud, file infector, modular payloads, C2 communication, social engineering',
    2: 'Lollipop (Adware) - keywords: ad injection, browser hijacker, persistent pop-ups, software bundling, drive-by download, user tracking, monetization fraud',
    3: 'Kelihos_v3 (Botnet) - keywords: spam campaigns, data exfiltration, peer-to-peer C2, cryptocurrency theft, DDoS capabilities, fast flux DNS, payload delivery',
    4: 'Vundo (Trojan) - keywords: rogue security software, pop-up ads, browser redirection, DLL injection, rootkit techniques, persistence mechanisms, system slowdown',
    5: 'Simda (Backdoor) - keywords: system backdoor, remote access, privilege escalation, domain flux, downloader functionality, exploit kits, malware distribution',
    6: 'Tracur (Trojan) - keywords: malicious redirection, search engine hijack, browser plugin abuse, affiliate fraud, drive-by infection, obfuscation, registry modification',
    7: 'Kelihos_v1 (Botnet) - keywords: command-and-control, spam propagation, credential theft, decentralized architecture, malware loader, modular design, anonymity evasion',
    8: 'Obfuscator.ACY (Obfuscator) - keywords: polymorphic code, encrypted payloads, anti-analysis, code packing, evasion tactics, runtime decryption, sandbox detection',
    9: 'Gatak (Backdoor) - keywords: remote administration, software exploit, legitimate software abuse, credential theft, C2 server communication, lateral movement, privilege abuse'
}

# Function to classify a .bytes file
def classify_bytes_file(file_path, model_path='saved_w.model', normal_threshold=0.5):
    """
    Classify a .bytes file using the trained XGBoost model.
    """
    try:
        bst = xgb.Booster()
        bst.load_model(model_path)
    except Exception as e:
        return {'error': f"Failed to load model: {e}"}
    
    # Extract features
    features = extract_features(file_path)
    
    # Convert to numpy array and create DMatrix for prediction
    X = np.array(features).reshape(1, -1)
    dmatrix = xgb.DMatrix(X)
    
    # Predict
    prediction = bst.predict(dmatrix)
    max_prob = float(np.max(prediction[0]))  # Convert to Python float
    predicted_class = int(np.argmax(prediction, axis=1)[0]) + 1  # Convert to Python int
    
    # Check for normal file (low confidence in all malware classes)
    if max_prob < normal_threshold:
        predicted_class = 0
    
    # Get probability distribution (convert numpy floats to Python floats)
    probabilities = {
        malware_mapping[i]: float(0.0 if i == 0 else prediction[0][i-1])
        for i in range(10)
    }
    
    return {
        'predicted_malware': malware_mapping[predicted_class],
        'max_probability': max_prob,
        'probabilities': probabilities
    }

# Beautified output function
def print_beautified_result(file_path, result):
    """
    Print classification result in a visually appealing format.
    """
    print("\n" + "="*60)
    print(f" Malware Classification Result ".center(60, "*"))
    print("="*60)
    print(f"File: {file_path}")
    print("-"*60)
    
    if 'error' in result:
        print(f"Error: {result['error']}")
        print("="*60)
        return
    
    print(f"Predicted: {result['predicted_malware']}")
    if result['predicted_malware'] != malware_mapping[0]:
        print(f"Confidence: {result['max_probability']:.4f}")
    else:
        print("Confidence: Low (below threshold, likely normal)")
    print("-"*60)
    print("Class Probabilities:")
    print("-"*60)
    for malware_name, prob in result['probabilities'].items():
        prob_str = f"{prob:.4f}" if prob > 0 else "N/A "
        print(f"{malware_name:<70} | {prob_str}")
    print("="*60 + "\n")

# Example usage
if __name__ == "__main__":
    # Replace with your .bytes file path
    test_file_path = "/kaggle/input/test-virus/shubh.bytes"
    
    try:
        result = classify_bytes_file(test_file_path)
        print_beautified_result(test_file_path, result)
            
    except FileNotFoundError:
        print_beautified_result(test_file_path, {'error': f"File {test_file_path} not found"})
    except Exception as e:
        print_beautified_result(test_file_path, {'error': f"Unexpected error: {e}"})